# üíª Uso Program√°tico

APIDoc puede ser utilizado program√°ticamente en aplicaciones Node.js, permitiendo integraci√≥n automatizada en pipelines de CI/CD y flujos de trabajo personalizados.

## üöÄ Instalaci√≥n y Configuraci√≥n

### Instalaci√≥n
```bash
# Como dependencia de desarrollo
npm install --save-dev @hrefcl/apidoc

# Como dependencia global
npm install -g @hrefcl/apidoc
```

### Importaci√≥n ES6/ESM
```javascript
import { createDoc } from '@hrefcl/apidoc';
```

### Importaci√≥n CommonJS
```javascript
const { createDoc } = require('@hrefcl/apidoc');
```

## üìã API Principal

### createDoc(options)
Funci√≥n principal para generar documentaci√≥n program√°ticamente.

#### Opciones Disponibles
```typescript
interface ApiDocOptions {
  src: string[];           // Directorios fuente
  dest: string;           // Directorio de salida
  dryRun?: boolean;       // Solo validar, no generar archivos
  silent?: boolean;       // Suprimir salida en consola
  verbose?: boolean;      // Salida detallada
  debug?: boolean;        // Modo debug
  config?: string;        // Ruta al archivo de configuraci√≥n
  template?: string;      // Directorio de template personalizado
  filterVersion?: string; // Filtrar por versi√≥n espec√≠fica
  mqttOnly?: boolean;     // Solo endpoints MQTT
  failOnMqttSchemaError?: boolean; // Fallar en errores de schema MQTT
}
```

## üéØ Ejemplos B√°sicos

### Uso Simple
```javascript
import path from 'path';
import { createDoc } from '@hrefcl/apidoc';

// Configuraci√≥n b√°sica
const result = await createDoc({
  src: [path.resolve(__dirname, 'src')],
  dest: path.resolve(__dirname, 'docs'),
  dryRun: false,
  silent: false
});

if (result.success) {
  console.log('‚úÖ Documentaci√≥n generada exitosamente');
  console.log(`üìÅ Archivos generados en: ${result.dest}`);
} else {
  console.error('‚ùå Error generando documentaci√≥n:', result.error);
}
```

### Con Configuraci√≥n Personalizada
```javascript
import { createDoc } from '@hrefcl/apidoc';

const options = {
  src: ['./src/api', './src/controllers'],
  dest: './public/docs',
  config: './custom-apidoc.json',
  template: './custom-template',
  verbose: true,
  filterVersion: '2.0.0'
};

try {
  const result = await createDoc(options);

  console.log('üìä Estad√≠sticas:');
  console.log(`- Archivos procesados: ${result.stats.filesProcessed}`);
  console.log(`- Endpoints documentados: ${result.stats.endpointsFound}`);
  console.log(`- Grupos generados: ${result.stats.groupsGenerated}`);
} catch (error) {
  console.error('Error:', error.message);
  process.exit(1);
}
```

## üîß Integraci√≥n en Build Scripts

### package.json Scripts
```json
{
  "scripts": {
    "docs": "node scripts/generate-docs.js",
    "docs:dev": "node scripts/generate-docs.js --dev",
    "docs:watch": "node scripts/watch-docs.js",
    "build": "npm run compile && npm run docs"
  }
}
```

### Script de Generaci√≥n (generate-docs.js)
```javascript
#!/usr/bin/env node

import { createDoc } from '@hrefcl/apidoc';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const isDev = process.argv.includes('--dev');

async function generateDocs() {
  console.log('üöÄ Iniciando generaci√≥n de documentaci√≥n...');

  const startTime = Date.now();

  const options = {
    src: [
      resolve(__dirname, '../src/api'),
      resolve(__dirname, '../src/controllers')
    ],
    dest: resolve(__dirname, '../docs'),
    dryRun: false,
    silent: false,
    verbose: isDev,
    debug: isDev
  };

  try {
    const result = await createDoc(options);

    const duration = Date.now() - startTime;

    if (result.success) {
      console.log('‚úÖ Documentaci√≥n generada exitosamente');
      console.log(`‚è±Ô∏è  Tiempo: ${duration}ms`);
      console.log(`üìÅ Ubicaci√≥n: ${result.dest}`);

      // Mostrar estad√≠sticas detalladas en modo dev
      if (isDev && result.stats) {
        console.log('\nüìä Estad√≠sticas detalladas:');
        console.log(`- Archivos procesados: ${result.stats.filesProcessed}`);
        console.log(`- L√≠neas de c√≥digo: ${result.stats.linesOfCode}`);
        console.log(`- Endpoints REST: ${result.stats.restEndpoints}`);
        console.log(`- Endpoints MQTT: ${result.stats.mqttEndpoints}`);
        console.log(`- Grupos generados: ${result.stats.groupsGenerated}`);
      }
    } else {
      console.error('‚ùå Error generando documentaci√≥n');
      console.error(result.error);
      process.exit(1);
    }
  } catch (error) {
    console.error('üí• Error inesperado:', error.message);
    if (isDev) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

generateDocs();
```

## üëÄ Watch Mode para Desarrollo

### Script de Watch (watch-docs.js)
```javascript
import { watch } from 'chokidar';
import { createDoc } from '@hrefcl/apidoc';
import { debounce } from 'lodash-es';
import path from 'path';

const srcDirs = ['./src/api', './src/controllers'];
const destDir = './docs';

// Funci√≥n debounced para evitar regeneraci√≥n excesiva
const generateDocs = debounce(async () => {
  console.log('üîÑ Regenerando documentaci√≥n...');

  try {
    const result = await createDoc({
      src: srcDirs.map(dir => path.resolve(dir)),
      dest: path.resolve(destDir),
      silent: true // Modo silencioso para watch
    });

    if (result.success) {
      console.log('‚úÖ Documentaci√≥n actualizada');
    } else {
      console.error('‚ùå Error:', result.error);
    }
  } catch (error) {
    console.error('üí• Error:', error.message);
  }
}, 1000); // Esperar 1 segundo despu√©s del √∫ltimo cambio

// Configurar watcher
const watcher = watch(srcDirs, {
  ignored: [
    '**/node_modules/**',
    '**/.git/**',
    '**/tmp/**'
  ],
  persistent: true
});

watcher
  .on('change', (path) => {
    console.log(`üìù Archivo modificado: ${path}`);
    generateDocs();
  })
  .on('add', (path) => {
    console.log(`‚ûï Archivo a√±adido: ${path}`);
    generateDocs();
  })
  .on('unlink', (path) => {
    console.log(`üóëÔ∏è  Archivo eliminado: ${path}`);
    generateDocs();
  });

console.log('üëÄ Observando cambios en:', srcDirs);
console.log('üí° Presiona Ctrl+C para detener');

// Generar documentaci√≥n inicial
generateDocs();
```

## üîÑ Integraci√≥n CI/CD

### GitHub Actions
```yaml
# .github/workflows/docs.yml
name: Generate API Documentation

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  docs:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Generate documentation
      run: node scripts/generate-docs.js

    - name: Upload documentation
      uses: actions/upload-artifact@v3
      with:
        name: api-docs
        path: docs/

    - name: Deploy to GitHub Pages
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs
```

### Docker Integration
```dockerfile
# Dockerfile para generaci√≥n de docs
FROM node:20-alpine

WORKDIR /app

# Copiar archivos de configuraci√≥n
COPY package*.json ./
COPY apidoc.json ./

# Instalar dependencias
RUN npm ci --only=production

# Copiar c√≥digo fuente
COPY src/ ./src/
COPY scripts/ ./scripts/

# Generar documentaci√≥n
RUN node scripts/generate-docs.js

# Servir documentaci√≥n
FROM nginx:alpine
COPY --from=0 /app/docs /usr/share/nginx/html
EXPOSE 80
```

## üõ†Ô∏è Configuraci√≥n Avanzada

### Validaci√≥n con Dry Run
```javascript
import { createDoc } from '@hrefcl/apidoc';

async function validateDocs() {
  const result = await createDoc({
    src: ['./src'],
    dest: './tmp', // No se usa en dry run
    dryRun: true,  // Solo validar
    silent: false
  });

  if (result.success) {
    console.log('‚úÖ Documentaci√≥n v√°lida');
    return true;
  } else {
    console.error('‚ùå Errores encontrados:');
    result.errors?.forEach(error => {
      console.error(`- ${error.file}:${error.line} - ${error.message}`);
    });
    return false;
  }
}

// Usar en scripts de pre-commit
if (!(await validateDocs())) {
  process.exit(1);
}
```

### Configuraci√≥n Multi-Proyecto
```javascript
// Generar documentaci√≥n para m√∫ltiples proyectos
const projects = [
  {
    name: 'user-api',
    src: ['./services/user-api/src'],
    dest: './docs/user-api'
  },
  {
    name: 'product-api',
    src: ['./services/product-api/src'],
    dest: './docs/product-api'
  },
  {
    name: 'order-api',
    src: ['./services/order-api/src'],
    dest: './docs/order-api'
  }
];

async function generateAllDocs() {
  console.log('üöÄ Generando documentaci√≥n para todos los proyectos...');

  const results = await Promise.allSettled(
    projects.map(async (project) => {
      console.log(`üìù Procesando ${project.name}...`);

      return createDoc({
        src: project.src,
        dest: project.dest,
        silent: true
      });
    })
  );

  // Reportar resultados
  results.forEach((result, index) => {
    const project = projects[index];

    if (result.status === 'fulfilled' && result.value.success) {
      console.log(`‚úÖ ${project.name}: Completado`);
    } else {
      console.error(`‚ùå ${project.name}: Error`);
      if (result.status === 'rejected') {
        console.error(result.reason);
      } else {
        console.error(result.value.error);
      }
    }
  });
}

generateAllDocs();
```

## üìä An√°lisis y Estad√≠sticas

### Reporte Detallado
```javascript
async function generateReport() {
  const result = await createDoc({
    src: ['./src'],
    dest: './docs',
    verbose: true
  });

  if (result.success && result.stats) {
    // Generar reporte en JSON
    const report = {
      timestamp: new Date().toISOString(),
      project: process.env.npm_package_name,
      version: process.env.npm_package_version,
      stats: result.stats,
      coverage: {
        documented: result.stats.endpointsFound,
        total: result.stats.endpointsTotal,
        percentage: Math.round((result.stats.endpointsFound / result.stats.endpointsTotal) * 100)
      }
    };

    // Guardar reporte
    await fs.writeFile('./docs/report.json', JSON.stringify(report, null, 2));

    console.log('üìä Reporte generado:');
    console.log(`- Cobertura: ${report.coverage.percentage}%`);
    console.log(`- Endpoints: ${report.stats.endpointsFound}/${report.stats.endpointsTotal}`);
  }
}
```

## üîå Hooks y Extensibilidad

### Pre y Post Hooks
```javascript
async function generateWithHooks() {
  // Pre-hook: Limpiar directorio
  console.log('üßπ Limpiando directorio de salida...');
  await fs.rm('./docs', { recursive: true, force: true });

  // Generar documentaci√≥n
  const result = await createDoc({
    src: ['./src'],
    dest: './docs'
  });

  if (result.success) {
    // Post-hook: Comprimir para distribuci√≥n
    console.log('üì¶ Comprimiendo documentaci√≥n...');
    await compress('./docs', './docs.zip');

    // Post-hook: Subir a CDN
    console.log('‚òÅÔ∏è  Subiendo a CDN...');
    await uploadToCDN('./docs');
  }

  return result;
}
```

El uso program√°tico de APIDoc te permite integrar la generaci√≥n de documentaci√≥n en cualquier flujo de trabajo, automatizar actualizaciones y crear pipelines robustos de documentaci√≥n.