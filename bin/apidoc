#!/usr/bin/env node

'use strict';

/*
 * APIDoc v5 - Modern Interactive CLI
 * https://apidoc.app
 *
 * Author: Href Spa <hola@apidoc.app>
 * Copyright (c) 2025 Href SpA
 * Licensed under the MIT license.
 */

const path = require('path');
const fs = require('fs');
const { Command } = require('commander');
const pc = require('picocolors');
const clack = require('@clack/prompts');

// Try compiled version first, fallback to source
let apidoc;
try {
    apidoc = require(path.join(__dirname, '..', 'dist', 'core', 'apidoc', 'index.js'));
} catch (_e) {
    apidoc = require(path.join(__dirname, '..', 'core', 'apidoc', 'index'));
}

const pkgJson = require(path.join(__dirname, '..', 'package.json'));

// ============================================================
// INTERACTIVE INITIALIZATION
// ============================================================

async function interactiveInit() {
    console.clear();

    clack.intro(pc.bgBlue(pc.black(' APIDoc v5 - Project Setup ')));

    const projectPath = await clack.text({
        message: 'Where do you want to create your docs?',
        placeholder: '.',
        initialValue: '.',
        validate(value) {
            if (!value) return 'Please enter a path';
        }
    });

    if (clack.isCancel(projectPath)) {
        clack.cancel('Operation cancelled');
        process.exit(0);
    }

    const configPath = path.join(projectPath, 'apidoc.json');

    // Check if config exists
    if (fs.existsSync(configPath)) {
        const overwrite = await clack.confirm({
            message: `${pc.yellow('apidoc.json')} already exists. Overwrite?`,
            initialValue: false
        });

        if (clack.isCancel(overwrite) || !overwrite) {
            clack.cancel('Setup cancelled');
            process.exit(0);
        }
    }

    const spinner = clack.spinner();
    spinner.start('Detecting project information...');

    // Try to detect package.json
    let packageInfo = null;
    const packagePath = path.join(projectPath, 'package.json');

    if (fs.existsSync(packagePath)) {
        try {
            const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            packageInfo = {
                name: pkg.name || 'My API',
                version: pkg.version || '1.0.0',
                description: pkg.description || 'API Documentation',
                author: pkg.author || '',
                homepage: pkg.homepage || '',
                repository: pkg.repository?.url || pkg.repository || ''
            };
            spinner.stop(pc.green('âœ“') + ' Found package.json');
        } catch (_e) {
            spinner.stop(pc.yellow('!') + ' Invalid package.json, using defaults');
        }
    } else {
        spinner.stop(pc.dim('No package.json found, using defaults'));
    }

    // Interactive configuration
    const projectName = await clack.text({
        message: 'Project name?',
        initialValue: packageInfo?.name || 'My API',
        placeholder: 'My API'
    });

    const projectVersion = await clack.text({
        message: 'Version?',
        initialValue: packageInfo?.version || '1.0.0',
        placeholder: '1.0.0'
    });

    const projectDescription = await clack.text({
        message: 'Description?',
        initialValue: packageInfo?.description || 'API Documentation',
        placeholder: 'API Documentation'
    });

    const apiUrl = await clack.text({
        message: 'API Base URL?',
        initialValue: packageInfo?.homepage || 'https://api.example.com',
        placeholder: 'https://api.example.com'
    });

    // Input configuration - categorized approach
    const useCategories = await clack.confirm({
        message: 'Use categorized inputs? (Recommended for v5)',
        initialValue: true
    });

    let inputConfig;

    if (useCategories) {
        const categories = await clack.multiselect({
            message: 'Which categories do you want to document?',
            options: [
                { value: 'api', label: 'REST API', hint: 'Standard REST endpoints' },
                { value: 'tsdoc', label: 'TypeScript', hint: 'TS interfaces and types' },
                { value: 'models', label: 'Data Models', hint: 'Schemas and models' },
                { value: 'mqtt', label: 'MQTT', hint: 'IoT protocols' },
                { value: 'openapi', label: 'OpenAPI', hint: 'OpenAPI specs' },
                { value: 'docs', label: 'Documentation', hint: 'Markdown files' }
            ],
            initialValues: ['api']
        });

        if (clack.isCancel(categories)) {
            clack.cancel('Setup cancelled');
            process.exit(0);
        }

        inputConfig = { inputs: {} };

        for (const category of categories) {
            const dir = await clack.text({
                message: `Path for ${pc.cyan(category)} category?`,
                initialValue: `./${category}`,
                placeholder: `./${category}`
            });

            if (clack.isCancel(dir)) {
                clack.cancel('Setup cancelled');
                process.exit(0);
            }

            inputConfig.inputs[category] = [dir];
        }
    } else {
        // Legacy single input
        const inputDir = await clack.text({
            message: 'Source directory?',
            initialValue: './src',
            placeholder: './src'
        });

        if (clack.isCancel(inputDir)) {
            clack.cancel('Setup cancelled');
            process.exit(0);
        }

        inputConfig = { input: [inputDir] };
    }

    // Output format options
    const outputFormats = await clack.multiselect({
        message: 'What formats do you want to generate?',
        options: [
            { value: 'html', label: 'HTML Documentation', hint: 'Interactive web docs' },
            { value: 'openapi', label: 'OpenAPI Spec', hint: 'Swagger/OpenAPI 3.0' },
            { value: 'markdown', label: 'Markdown', hint: 'Portable markdown docs' },
            { value: 'json', label: 'JSON', hint: 'Raw API data' }
        ],
        initialValues: ['html']
    });

    if (clack.isCancel(outputFormats)) {
        clack.cancel('Setup cancelled');
        process.exit(0);
    }

    // Authentication
    const needsAuth = await clack.confirm({
        message: 'Require authentication to view docs?',
        initialValue: false
    });

    let authConfig = { active: false };

    if (needsAuth) {
        const authUrl = await clack.text({
            message: 'Authentication endpoint URL?',
            placeholder: 'https://auth.example.com/login'
        });

        authConfig = {
            active: true,
            urlAuth: authUrl,
            value_form: {
                email: 'email',
                password: 'password'
            },
            response_success: 200,
            response_error: 401
        };
    }

    // Build final configuration
    const config = {
        name: projectName,
        version: projectVersion,
        description: projectDescription,
        title: `${projectName} Documentation`,
        url: apiUrl,
        ...inputConfig,
        template: {
            showRequiredLabels: true,
            withCompare: false,
            withGenerator: true
        },
        login: authConfig
    };

    // Add format-specific options
    if (outputFormats.includes('openapi')) {
        config.openapi = true;
    }
    if (outputFormats.includes('markdown')) {
        config.markdownExport = true;
    }
    if (outputFormats.includes('json')) {
        config.writeJson = true;
    }

    // Write configuration
    const writeSpinner = clack.spinner();
    writeSpinner.start('Creating apidoc.json...');

    // Create directory recursively if it doesn't exist
    const configDir = path.dirname(configPath);
    if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
    }

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');

    writeSpinner.stop(pc.green('âœ“') + ' Configuration saved');

    // Summary
    const s = clack.spinner();
    s.start('Preparing summary...');
    await new Promise(resolve => setTimeout(resolve, 500));
    s.stop();

    clack.note(
        [
            `${pc.cyan('Project:')} ${config.name} v${config.version}`,
            `${pc.cyan('Description:')} ${config.description}`,
            `${pc.cyan('API URL:')} ${config.url}`,
            `${pc.cyan('Categories:')} ${useCategories ? Object.keys(config.inputs).join(', ') : 'Legacy mode'}`,
            `${pc.cyan('Formats:')} ${outputFormats.join(', ')}`,
            `${pc.cyan('Auth Required:')} ${needsAuth ? 'Yes' : 'No'}`
        ].join('\n'),
        pc.bold('Configuration Summary')
    );

    const nextSteps = clack.note(
        [
            `${pc.dim('1.')} Add API documentation comments to your code`,
            `${pc.dim('2.')} Run ${pc.cyan('apidoc generate')} to create docs`,
            `${pc.dim('3.')} View docs with ${pc.cyan('npx serve doc')}`
        ].join('\n'),
        pc.bold('Next Steps')
    );

    clack.outro(pc.green('Setup complete! ğŸ‰'));
}

// ============================================================
// INTERACTIVE EXPORT
// ============================================================

async function interactiveExport() {
    console.clear();

    clack.intro(pc.bgBlue(pc.black(' APIDoc v5 - Export Documentation ')));

    const format = await clack.select({
        message: 'What format do you want to export?',
        options: [
            { value: 'markdown', label: 'Markdown', hint: 'Portable .md files' },
            { value: 'openapi', label: 'OpenAPI 3.0', hint: 'Swagger specification' },
            { value: 'json', label: 'JSON', hint: 'Raw API data' },
            { value: 'postman', label: 'Postman', hint: 'Postman collection (coming soon)', disabled: true }
        ]
    });

    if (clack.isCancel(format)) {
        clack.cancel('Export cancelled');
        process.exit(0);
    }

    const category = await clack.select({
        message: 'Which category to export?',
        options: [
            { value: 'all', label: 'All categories', hint: 'Export everything' },
            { value: 'api', label: 'REST API only' },
            { value: 'tsdoc', label: 'TypeScript only' },
            { value: 'models', label: 'Models only' },
            { value: 'mqtt', label: 'MQTT only' }
        ],
        initialValue: 'all'
    });

    if (clack.isCancel(category)) {
        clack.cancel('Export cancelled');
        process.exit(0);
    }

    const outputPath = await clack.text({
        message: 'Output path?',
        initialValue: format === 'markdown' ? './docs' : `./${format}.json`,
        placeholder: './output'
    });

    if (clack.isCancel(outputPath)) {
        clack.cancel('Export cancelled');
        process.exit(0);
    }

    clack.note(
        [
            `${pc.cyan('Format:')} ${format}`,
            `${pc.cyan('Category:')} ${category}`,
            `${pc.cyan('Output:')} ${outputPath}`
        ].join('\n'),
        'Export Configuration'
    );

    const spinner = clack.spinner();
    spinner.start(`Exporting to ${format}...`);

    // TODO: Implement actual export logic here
    await new Promise(resolve => setTimeout(resolve, 2000));

    spinner.stop(pc.green('âœ“') + ` Exported to ${outputPath}`);

    clack.outro(pc.green('Export complete! ğŸ‰'));
}

// ============================================================
// INTERACTIVE HELP
// ============================================================

async function interactiveHelp() {
    console.clear();

    clack.intro(pc.bgBlue(pc.black(' APIDoc v5 - What do you want to do? ')));

    const action = await clack.select({
        message: 'Choose an action:',
        options: [
            {
                value: 'init',
                label: 'Initialize new project',
                hint: 'Create apidoc.json with guided setup'
            },
            {
                value: 'generate',
                label: 'Generate documentation',
                hint: 'Create HTML docs from your code'
            },
            {
                value: 'export',
                label: 'Export to format',
                hint: 'Markdown, OpenAPI, JSON, etc.'
            },
            {
                value: 'transform',
                label: 'Transform code comments',
                hint: 'Convert APIDoc â†’ Markdown/OpenAPI/JSON'
            },
            {
                value: 'learn',
                label: 'Learn about APIDoc',
                hint: 'Documentation and examples'
            }
        ]
    });

    if (clack.isCancel(action)) {
        clack.cancel('Cancelled');
        process.exit(0);
    }

    switch (action) {
        case 'init':
            await interactiveInit();
            break;
        case 'export':
            await interactiveExport();
            break;
        case 'generate':
            clack.outro('Use: apidoc generate');
            break;
        case 'transform':
            clack.note(
                [
                    `${pc.cyan('Code â†’ Markdown:')} apidoc export markdown`,
                    `${pc.cyan('Code â†’ OpenAPI:')} apidoc export openapi`,
                    `${pc.cyan('Code â†’ JSON:')} apidoc export json`,
                    `${pc.cyan('TypeScript â†’ Docs:')} apidoc --category tsdoc export markdown`
                ].join('\n'),
                'Transform Commands'
            );
            clack.outro('Happy documenting! ğŸ“š');
            break;
        case 'learn':
            clack.note(
                [
                    `${pc.cyan('Homepage:')} https://apidoc.app`,
                    `${pc.cyan('Documentation:')} https://apidoc.app/docs`,
                    `${pc.cyan('Examples:')} https://apidoc.app/examples`,
                    `${pc.cyan('GitHub:')} https://github.com/hrefcl/apidoc`
                ].join('\n'),
                'Resources'
            );
            clack.outro('Happy learning! ğŸš€');
            break;
    }
}

// ============================================================
// CLI PROGRAM
// ============================================================

const program = new Command();

program
    .name('apidoc')
    .version(pkgJson.version)
    .description('APIDoc v5 - Modern API Documentation Generator');

// Init command
program
    .command('init')
    .description('Initialize APIDoc project with interactive setup')
    .option('--no-interactive', 'Skip interactive prompts')
    .action(async (options) => {
        if (options.interactive === false) {
            // Non-interactive init (TODO)
            console.log('Non-interactive init coming soon');
        } else {
            await interactiveInit();
        }
    });

// Generate command
program
    .command('generate')
    .description('Generate HTML documentation')
    .option('-c, --config <file>', 'Config file path', 'apidoc.json')
    .option('-i, --input <dirs...>', 'Input directories')
    .option('-o, --output <dir>', 'Output directory', 'doc')
    .option('-w, --watch', 'Watch mode', false)
    .option('-v, --verbose', 'Verbose output', false)
    .option('-d, --debug', 'Debug mode', false)
    .option('--filter-version <version>', 'Filter documentation by specific API version (e.g., 2.0.0)')
    .action(async (options) => {
        try {
            const templatePath = path.join(__dirname, '../apps/apidoc-template-v5/');

            const apidocOptions = {
                src: options.input || [process.cwd()],
                dest: options.output,
                template: templatePath,
                config: options.config,
                verbose: options.verbose,
                debug: options.debug,
                colorize: true,
                excludeFilters: ['node_modules', 'apidoc.config.js'],
                includeFilters: ['.*\\.(clj|cls|coffee|cpp|cs|dart|erl|exs?|go|groovy|ino?|java|js|jsx|kt|litcoffee|lua|mjs|p|php?|pl|pm|py|rb|scala|ts|tsx|vue)$'],
                filterBy: options.filterVersion ? `version=${options.filterVersion}` : undefined,
            };

            if (options.watch) {
                const nodemon = require('nodemon');

                console.log(pc.yellow('ğŸ‘€ Watch mode enabled'));
                console.log(pc.dim('Listening for changes...\n'));

                nodemon({
                    watch: apidocOptions.src,
                    ext: 'js,ts,jsx,tsx,vue,py,php,rb,go,java'
                });

                nodemon
                    .on('quit', function () {
                        console.log(pc.red('\nğŸ›‘ Process terminated.'));
                        process.exit();
                    })
                    .on('restart', async function () {
                        const startTime = Date.now();
                        console.log(pc.cyan('ğŸ”„ Changes detected, rebuilding...'));

                        const result = await apidoc.createDoc(apidocOptions);
                        const duration = ((Date.now() - startTime) / 1000).toFixed(2);

                        if (result !== false) {
                            const d = new Date();
                            console.log(pc.green('âœ… Build finished') + ` in ${pc.bold(duration + 's')} at ${pc.dim(d.getHours() + ':' + d.getMinutes() + ':' + d.getSeconds())}\n`);
                        } else {
                            console.error(pc.red('âŒ Build failed') + ` after ${pc.bold(duration + 's')}\n`);
                        }
                    });
            } else {
                // Show banner
                const banner = pc.cyan(`
     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•
`);
                const version = pc.bold(pc.white(`v${pkgJson.version}`));
                const url = pc.dim('https://apidoc.app');

                console.log(banner);
                console.log(`            ${version} â€¢ ${url}\n`);

                const spinner = clack.spinner();
                spinner.start('Generating documentation...');

                const startTime = Date.now();
                const result = await apidoc.createDoc(apidocOptions);
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);

                if (result === false) {
                    spinner.stop(pc.red('âŒ Documentation generation failed'));
                    process.exit(1);
                } else {
                    spinner.stop(pc.green('âœ… Documentation generated successfully'));

                    if (options.verbose && result) {
                        console.log(`\n${pc.bold(pc.blue('ğŸ“Š Statistics:'))}`);
                        console.log(`${pc.cyan('â€¢')} Build time: ${pc.bold(duration + 's')}`);
                        console.log(`${pc.cyan('â€¢')} Output: ${pc.bold(options.output)}`);

                        if (result.data?.length) {
                            console.log(`${pc.cyan('â€¢')} API endpoints: ${pc.bold(result.data.length)}`);
                        }
                        if (result.project) {
                            console.log(`${pc.cyan('â€¢')} Project: ${pc.bold(result.project.name || 'Unknown')} v${pc.bold(result.project.version || '1.0.0')}`);
                        }
                    }

                    console.log(`\n${pc.bold(pc.green('ğŸ‰ Done!'))} Documentation ready at ${pc.cyan(options.output)}`);
                    console.log(`${pc.dim('ğŸ’¡ Tip:')} Use ${pc.cyan('npx serve')} ${pc.cyan(options.output)} to preview`);
                }
            }
        } catch (error) {
            console.error(pc.red('âŒ Error:'), error.message);
            if (options.debug) {
                console.error(error.stack);
            }
            process.exit(1);
        }
    });

// Export command
program
    .command('export <format>')
    .description('Export documentation to specific format (markdown, openapi, json)')
    .option('-c, --config <file>', 'Config file path', 'apidoc.json')
    .option('-i, --input <dirs...>', 'Input directories')
    .option('-o, --output <path>', 'Output path')
    .option('--category <name>', 'Export specific category only')
    .option('-v, --verbose', 'Verbose output', false)
    .option('--filter-version <version>', 'Filter documentation by specific API version (e.g., 2.0.0)')
    .option('--no-interactive', 'Skip interactive prompts')
    .action(async (format, options) => {
        if (options.interactive === false) {
            try {
                const spinner = clack.spinner();
                spinner.start(`Exporting to ${format}...`);

                // Parse apidoc first to get data
                const apidocOptions = {
                    src: options.input || [process.cwd()],
                    dest: 'tmp/export-temp',
                    template: path.join(__dirname, '../apps/apidoc-template-v5/'),
                    config: options.config,
                    verbose: options.verbose,
                    colorize: true,
                    excludeFilters: ['node_modules'],
                    includeFilters: ['.*\\.(js|ts|jsx|tsx|vue|py|php|rb|go|java)$'],
                    filterBy: options.filterVersion ? `version=${options.filterVersion}` : undefined,
                };

                const result = await apidoc.createDoc(apidocOptions);

                if (!result || result === false) {
                    spinner.stop(pc.red('âŒ Failed to parse documentation'));
                    process.exit(1);
                }

                // Now export based on format
                const outputPath = options.output || `./${format === 'markdown' ? 'docs' : format}.${format === 'json' ? 'json' : format === 'openapi' ? 'yaml' : 'md'}`;

                if (format === 'markdown') {
                    const { generateMarkdownFileSystem } = require(path.join(__dirname, '../dist/core/markdown'));

                    await generateMarkdownFileSystem({
                        apiDocProjectData: result.project,
                        apiDocApiData: result.data,  // Corrected: apiDocApiData not apiDocData
                        input: options.input?.[0] || process.cwd(),  // Required field
                        output: outputPath,
                        template: 'default',
                        multi: false,
                        createPath: true
                    });

                    spinner.stop(pc.green(`âœ… Exported to ${outputPath}`));
                } else if (format === 'openapi') {
                    const { convertToOpenApi } = require(path.join(__dirname, '../dist/core/exporters/openapi-converter'));

                    const openApiSpec = convertToOpenApi(result.data, result.project);
                    require('fs').writeFileSync(outputPath, JSON.stringify(openApiSpec, null, 2));

                    spinner.stop(pc.green(`âœ… Exported to ${outputPath}`));
                } else if (format === 'json') {
                    require('fs').writeFileSync(outputPath, JSON.stringify(result, null, 2));
                    spinner.stop(pc.green(`âœ… Exported to ${outputPath}`));
                } else {
                    spinner.stop(pc.red(`âŒ Unknown format: ${format}`));
                    console.log(pc.yellow('Supported formats: markdown, openapi, json'));
                    process.exit(1);
                }

                console.log(`\n${pc.bold(pc.green('ğŸ‰ Export complete!'))} File saved at ${pc.cyan(outputPath)}`);
            } catch (error) {
                console.error(pc.red('âŒ Error:'), error.message);
                process.exit(1);
            }
        } else {
            await interactiveExport();
        }
    });

// Help command (interactive)
program
    .command('help')
    .description('Interactive help system')
    .action(async () => {
        await interactiveHelp();
    });

// If no command specified, show interactive help
if (!process.argv.slice(2).length) {
    interactiveHelp().catch(err => {
        console.error('Error:', err);
        process.exit(1);
    });
} else {
    program.parse(process.argv);
}
